/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lobby.service.ts                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adda-sil <adda-sil@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/06/14 11:38:38 by adda-sil          #+#    #+#             */
/*   Updated: 2022/09/09 05:17:22 by adda-sil         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

import {
  Injectable,
  Inject,
  forwardRef,
  Logger,
  UnauthorizedException,
} from '@nestjs/common';
import Lobby, { LobbyId } from 'src/game/lobby.class';
import Player from 'src/game/player.class';

// import Store from 'redis-json';
import { User, UserService } from 'src/user';
import { SocketService } from 'src/socket';
// import { Match, MatchHistoryService } from 'src/match-history';
import { TS } from 'src/entities/root.entity';
@Injectable()
export class LobbyService {
  lobbies = new Map<LobbyId, Lobby>();
  afks = new Map<LobbyId, Lobby>();
  queue = new Array<User>();
  // match
  interval: NodeJS.Timer | null = null;
  // store: Store<Lobby>;
  logger = new Logger('LobbyService');
  constructor(
    // @InjectRedis() private readonly redis: Redis,
    @Inject(forwardRef(() => SocketService))
    public socketService: SocketService,
    @Inject(forwardRef(() => UserService))
    private userService: UserService, // @Inject(forwardRef(() => MatchHistoryService)) // private matchHistoryService: MatchHistoryService,
  ) {
    // this.store = new Store<Lobby>(redis, { prefix: 'game:' });
    // this.mock();
  }

  async mock() {
    const players = await Promise.all([
      this.userService.findById(1),
      this.userService.findById(2),
      // this.userService.findById(3),
      // this.userService.findById(6),
    ]);
    const lobby = await this.createLobby(players[0], 'Autogenerated game');
    for (let i = 0; i < 2; i++) lobby.addPlayer(new Player(players[i]));
    lobby.configure({ playersMax: 5 });
    // lobby.start();
  }

  matchmake() {
    console.log('Matchmaking...');
    if (this.queue.length < 2) return this.setMatchmaker(false);
    const u1 = this.queue.shift();
    const u2 = this.queue.shift();
    const u1_sock = this.socketService.getUserSocket(u1.id);
    const u2_sock = this.socketService.getUserSocket(u2.id);
    this.createLobby(u1, 'matchmade').then((value: Lobby) => {
      this.userJoinLobby(value, u1);
      this.userJoinLobby(value, u2);
      u1_sock.forEach((s) => s.emit('matchmake_done', value.id));
      u2_sock.forEach((s) => s.emit('matchmake_done', value.id));
      value.start();
    });
    this.socketService.socketio.emit('madeMatch');
  }

  setMatchmaker(bool = true) {
    if (bool && this.interval === null)
      return (this.interval = setInterval(() => this.matchmake(), 2000));
    clearInterval(this.interval);
    this.interval = null;
  }

  getLobbies(): Lobby[] {
    const lobbies = this.lobbies.values();
    return [...lobbies];
  }

  getLobby(id: LobbyId): Lobby {
    const lobby = this.lobbies.get(id);
    return lobby;
  }

  userIsInLobby(userId: number) {
    if (this.lobbies.has(userId)) return this.lobbies.get(userId);
    const lobbyPresent = this.getLobbies().find((l: Lobby) =>
      [...l.players.values()].find((p: Player) => p.user.id === userId),
    );
    return lobbyPresent;
  }

  removePlayer(lobbyId: number, user: User) {
    console.log('Has not lobby game');
    const lobby = this.getLobby(lobbyId);
    if (!lobby) return;
    lobby.removePlayer(user);
    const leaverSocket = this.socketService.getUserSocket(user.id);
    if (leaverSocket) {
      leaverSocket.forEach((s) => s.leave(lobby.roomId)); //.leave(lobby.roomId);
      leaverSocket.forEach((s) => s.send(`You left lobby ${lobby.roomId}`));
    }
  }

  async userJoinLobby(lobby: Lobby, user: User) {
    const socketOfJoiner = this.socketService.getUserSocket(user.id);
    if (lobby.players.has(user.id)) {
      socketOfJoiner.forEach((s) => s.join(lobby.roomId));
      this.logger.warn(
        `User ${user.id} already is in this lobby ${lobby.roomId}, rejoining the socket`,
      );
      return;
    }

    const currentLobbyOfUser = this.userIsInLobby(user.id);
    if (currentLobbyOfUser) {
      await this.userLeaveLobby(currentLobbyOfUser, user);
      this.logger.warn(
        `User ${user.id} already is in this lobby ${currentLobbyOfUser.roomId}, leaving the socket and the lobby`,
      );
      //this.removePlayer(stillInLobby.id, user);
    }

    if (lobby.players.size === lobby.playersMax) {
      this.logger.warn(
        `Max players (${lobby.playersMax}) has already been reached in this lobby ${lobby.roomId}`,
      );
      throw new UnauthorizedException('Lobby is full');
    }

    lobby.addPlayer(new Player(user));
    socketOfJoiner.forEach((s) => {
      s.join(lobby.roomId);
      s.data.lobby = lobby;
      s.send(`Welcome in lobby ${lobby.name}, ${user.name}`);
    });
    // socketOfJoiner.join(lobby.roomId);
    // socketOfJoiner.data.lobby = lobby;
    // socketOfJoiner.send(`Welcome in lobby ${lobby.name}, ${user.name}`);
    this.socketService.socketio
      .to(lobby.roomId)
      // .except(socketOfJoiner[0]?.id)
      .emit('lobby_change', lobby.id);
    //this.socketService.socketio.emit('online', { type: 'join' });
    this.socketService.socketio.emit('userJoinedLobby', user.id, lobby.id);
    this.logger.log(`User ${user.id} joined lobby ${lobby.roomId}`);
  }

  async userLeaveLobby(lobby: Lobby, user: User) {
    // eslint-disable-next-line prettier/prettier
    this.logger.log(
      'userLeaveLobby - user = ',
      user,
      ', lobby.id = ',
      lobby.id,
    );
    const socketOfLeaver = this.socketService.getUserSocket(user.id);
    if (lobby.players.has(user.id)) {
      this.removePlayer(lobby.id, user);
      socketOfLeaver.forEach((s) => s.leave(lobby.roomId));
      this.logger.warn(
        `User ${user.id} already is in this lobby ${lobby.roomId}, rejoining the socket`,
      );
      // check if the lobby still exists
      // eslint-disable-next-line prettier/prettier
      this.socketService.socketio.emit(
        'lobbyLeaver',
        user.id,
        user.name,
        lobby.id,
      );
      if (lobby.players.size === 0) {
        this.logger.log('userLeaveLobby - no more players, closing lobby');
        await this.closeLobby(lobby);
        this.socketService.socketio.emit('lobbyDeleted', user.id);
      } else if (lobby.host.id === user.id) {
        // change host if the player who left was host
        const nextHost = [...lobby.players.values()][0];
        this.logger.log('userLeaveLobby - host left, next host = ');
        console.log(nextHost.user);
        lobby.host = nextHost.user;
        lobby.sock.emit('lobbyNewHost', user.id, lobby.id);
      }
    }
    return null;
  }

  async kickUserFromLobby(lobby: Lobby, user: User) {
    // eslint-disable-next-line prettier/prettier
    this.logger.log(
      'kickUserFromLobby - user = ',
      user,
      ', lobby.id = ',
      lobby.id,
    );
    const socketOfLeaver = this.socketService.getUserSocket(user.id);
    if (lobby.players.has(user.id)) {
      lobby.sock.emit('lobbyKick', user.id, user.name, lobby.id);
      this.removePlayer(lobby.id, user);
      socketOfLeaver.forEach((s) => s.leave(lobby.roomId));
    }
    return null;
  }

  async killLobby(lobby: Lobby) {
    await this.closeLobby(lobby);
    this.socketService.socketio.emit('lobbyDeleted');
  }

  inviteUserToLobby(lobby: Lobby, from: User, invitee: User) {
    const socketOfInvitee = this.socketService.getUserSocket(invitee.id);
    socketOfInvitee?.forEach((s) =>
      s.emit('lobbyInvite', from.id, from.name, lobby.id),
    );
  }

  clearLobbies() {
    this.lobbies.clear();
  }

  async createLobby(host: User, name: string): Promise<Lobby> {
    const currentLobbyOfUser = this.userIsInLobby(host.id);
    if (currentLobbyOfUser) {
      await this.userLeaveLobby(currentLobbyOfUser, host);
      this.logger.warn(
        `User ${host.id} already is in this lobby ${currentLobbyOfUser.roomId}, leaving the socket and the lobby`,
      );
      //this.removePlayer(stillInLobby.id, user);
    }
    const lobby = new Lobby(this, host, name);
    this.lobbies.set(lobby.id, lobby);
    this.socketService.serializeEmit('lobbies_update', [
      ...this.lobbies.values(),
    ]);
    this.socketService.socketio.emit(
      'lobbyCreated',
      lobby.id,
      lobby.players.size,
    );
    return lobby;
  }

  closeLobby(lobby: Lobby, winner = null) {
    console.log('Stored match'); //, lobby.match);
    if (lobby.game) {
      lobby.game.stop();
      //      lobby.sock.emit('redirect', {
      //        name: 'profile',
      //      });
      lobby.sock.emit('gameOver', lobby.id);
      this.socketService.socketio.emit('other_game_over', lobby.id);
      lobby.match.finishedAt = TS.ts();
      lobby.match.save().then(() => {
        this.logger.log('Updated match', lobby.match);
      });
    }
    lobby.sock.socketsLeave(lobby.roomId);
    this.lobbies.delete(lobby.id);
  }

  removeMatchmake(disco: User) {
    const pos: number = this.queue.findIndex((u) => u.id === disco.id);
    if (pos !== -1) this.queue.splice(pos, 1);
    console.log(`queue is now ${this.queue.length} ppl`);
  }

  userMatchmake(host: User) {
    const currentLobbyOfUser = this.userIsInLobby(host.id);
    if (currentLobbyOfUser) {
      this.userLeaveLobby(currentLobbyOfUser, host);
      this.logger.warn(
        `User ${host.id} already is in this lobby ${currentLobbyOfUser.roomId}, leaving the socket and the lobby`,
      );
    }
    if (this.queue.find((e) => e.id === host.id) === undefined)
      this.queue.push(host);
    if (this.queue.length === 2 && this.interval === null) this.setMatchmaker();
    console.log(`queue is now ${this.queue.length} ppl`);
  }
}
