/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lobby.service.ts                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: adda-sil <adda-sil@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/06/14 11:38:38 by adda-sil          #+#    #+#             */
/*   Updated: 2022/08/22 18:03:29 by adda-sil         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

import {
  Injectable,
  Inject,
  forwardRef,
  Logger,
  UnauthorizedException,
} from '@nestjs/common';
import Lobby, { LobbyId } from 'src/game/lobby.class';
import Player from 'src/game/player.class';

// import Store from 'redis-json';
import { User, UserService } from 'src/user';
import { SocketService } from 'src/socket';
import { Match, MatchHistoryService } from 'src/match-history';
import { TS } from 'src/entities/root.entity';
@Injectable()
export class LobbyService {
  lobbies = new Map<LobbyId, Lobby>();
  afks = new Map<LobbyId, Lobby>();
  // store: Store<Lobby>;
  logger = new Logger('LobbyService');
  constructor(
    // @InjectRedis() private readonly redis: Redis,
    @Inject(forwardRef(() => SocketService))
    public socketService: SocketService,
    @Inject(forwardRef(() => UserService))
    private userService: UserService, // @Inject(forwardRef(() => MatchHistoryService)) // private matchHistoryService: MatchHistoryService,
  ) {
    // this.store = new Store<Lobby>(redis, { prefix: 'game:' });
    // this.mock();
  }

  async mock() {
    const players = await Promise.all([
      this.userService.findById(1),
      this.userService.findById(2),
      // this.userService.findById(3),
      // this.userService.findById(6),
    ]);
    const lobby = await this.createLobby(players[0], 'Autogenerated game');
    for (let i = 0; i < 2; i++) lobby.addPlayer(new Player(players[i]));
    lobby.configure({ playersMax: 5 });
    // lobby.start();
  }

  getLobbies(): Lobby[] {
    const lobbies = this.lobbies.values();
    return [...lobbies];
  }

  getLobby(id: LobbyId): Lobby {
    const lobby = this.lobbies.get(id);
    return lobby;
  }

  userIsInLobby(userId: number) {
    if (this.lobbies.has(userId)) return this.lobbies.get(userId);
    const lobbyPresent = this.getLobbies().find((l: Lobby) =>
      [...l.players.values()].find((p: Player) => p.user.id === userId),
    );
    return lobbyPresent;
  }

  removePlayer(lobbyId: number, user: User) {
    console.log('Has not lobby game');
    const lobby = this.getLobby(lobbyId);
    if (!lobby) return;
    lobby.removePlayer(user);
    const leaverSocket = this.socketService.getUserSocket(user.id);
    if (leaverSocket) {
      leaverSocket.leave(lobby.roomId);
      leaverSocket.send(`You left lobby ${lobby.roomId}`);
    }
  }

  async userJoinLobby(lobby: Lobby, user: User) {
    const socketOfJoiner = this.socketService.getUserSocket(user.id);
    if (lobby.players.has(user.id)) {
      socketOfJoiner.join(lobby.roomId);
      this.logger.warn(
        `User ${user.id} already is in this lobby ${lobby.roomId}, rejoining the socket`,
      );
      return;
    }

    const currentLobbyOfUser = this.userIsInLobby(user.id);
    if (currentLobbyOfUser) {
      await this.userLeaveLobby(currentLobbyOfUser, user);
      this.logger.warn(
        `User ${user.id} already is in this lobby ${currentLobbyOfUser.roomId}, leaving the socket and the lobby`,
      );
      //this.removePlayer(stillInLobby.id, user);
    }

    if (lobby.players.size === lobby.playersMax) {
      this.logger.warn(
        `Max players (${lobby.playersMax}) has already been reached in this lobby ${lobby.roomId}`,
      );
      throw new UnauthorizedException('Lobby is full');
    }

    lobby.addPlayer(new Player(user));
    socketOfJoiner.join(lobby.roomId);
    socketOfJoiner.data.lobby = lobby;
    socketOfJoiner.send(`Welcome in lobby ${lobby.name}, ${user.name}`);
    this.socketService.socketio
      .to(lobby.roomId)
      .except(socketOfJoiner.id)
      .emit('lobby_change', lobby.id);
    //this.socketService.socketio.emit('online', { type: 'join' });
    this.socketService.socketio.emit('userJoinedLobby', user.id, lobby.id);
    this.logger.log(`User ${user.id} joined lobby ${lobby.roomId}`);
  }

  async userLeaveLobby(lobby: Lobby, user: User) {
    // eslint-disable-next-line prettier/prettier
    this.logger.log(
      'userLeaveLobby - user = ',
      user,
      ', lobby.id = ',
      lobby.id,
    );
    const socketOfLeaver = this.socketService.getUserSocket(user.id);
    if (lobby.players.has(user.id)) {
      this.removePlayer(lobby.id, user);
      socketOfLeaver.leave(lobby.roomId);
      this.logger.warn(
        `User ${user.id} already is in this lobby ${lobby.roomId}, rejoining the socket`,
      );
      // check if the lobby still exists
      // eslint-disable-next-line prettier/prettier
      this.socketService.socketio.emit(
        'lobbyLeaver',
        user.id,
        user.name,
        lobby.id,
      );
      if (lobby.players.size === 0) {
        this.logger.log('userLeaveLobby - no more players, closing lobby');
        await this.closeLobby(lobby);
        this.socketService.socketio.emit('lobbyDeleted', user.id);
      } else if (lobby.host.id === user.id) {
        // change host if the player who left was host
        const nextHost = [...lobby.players.values()][0];
        this.logger.log('userLeaveLobby - host left, next host = ');
        console.log(nextHost.user);
        lobby.host = nextHost.user;
        lobby.sock.emit('lobbyNewHost', user.id, lobby.id);
      }
    }
    return null;
  }

  async kickUserFromLobby(lobby: Lobby, user: User) {
    // eslint-disable-next-line prettier/prettier
    this.logger.log(
      'kickUserFromLobby - user = ',
      user,
      ', lobby.id = ',
      lobby.id,
    );
    const socketOfLeaver = this.socketService.getUserSocket(user.id);
    if (lobby.players.has(user.id)) {
      lobby.sock.emit('lobbyKick', user.id, user.name, lobby.id);
      this.removePlayer(lobby.id, user);
      socketOfLeaver.leave(lobby.roomId);
    }
    return null;
  }

  setFinalePoints(lobby: Lobby, points: number) {
    // eslint-disable-next-line prettier/prettier
    this.logger.log(`setFinalPoints - points = ${points}`);
    lobby.finalePoints = points;
    this.logger.log(`setFinalPoints - lobby.game.finalCap = ${points}`);
    lobby.sock.emit('lobby_change', lobby.id);
    lobby.sock.emit('setFinalPoints', points);
    return null;
  }

  async killLobby(lobby: Lobby) {
    await this.closeLobby(lobby);
    this.socketService.socketio.emit('lobbyDeleted');
  }

  inviteUserToLobby(lobby: Lobby, from: User, invitee: User) {
    const socketOfInvitee = this.socketService.getUserSocket(invitee.id);
    socketOfInvitee?.emit('lobbyInvite', from.id, from.name, lobby.id);
  }

  clearLobbies() {
    this.lobbies.clear();
  }

  async createLobby(host: User, name: string): Promise<Lobby> {
    const currentLobbyOfUser = this.userIsInLobby(host.id);
    if (currentLobbyOfUser) {
      await this.userLeaveLobby(currentLobbyOfUser, host);
      this.logger.warn(
        `User ${host.id} already is in this lobby ${currentLobbyOfUser.roomId}, leaving the socket and the lobby`,
      );
      //this.removePlayer(stillInLobby.id, user);
    }
    const lobby = new Lobby(this, host, name);
    this.lobbies.set(lobby.id, lobby);
    this.socketService.serializeEmit('lobbies_update', [
      ...this.lobbies.values(),
    ]);
    this.socketService.socketio.emit(
      'lobbyCreated',
      lobby.id,
      lobby.players.size,
    );
    return lobby;
  }

  async closeLobby(lobby: Lobby, winner = null) {
    console.log('Stored match', lobby.match);
    if (lobby.game) {
      lobby.game.stop();
      //      lobby.sock.emit('redirect', {
      //        name: 'profile',
      //      });
      lobby.sock.emit('gameOver', lobby.id);
      this.socketService.socketio.emit('other_game_over', lobby.id);
      lobby.match.finishedAt = TS.ts();
      lobby.match = await lobby.match.save();
      console.log('Updated match', lobby.match);
    }
    lobby.sock.socketsLeave(lobby.roomId);
    this.lobbies.delete(lobby.id);
  }
}
